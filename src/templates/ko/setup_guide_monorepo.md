# 🤖 CodeSyncer 설정 가이드 for AI 어시스턴트 (모노레포)

> **AI 코딩 어시스턴트용**: 이 문서를 끝까지 읽고 지시사항을 따라 이 모노레포의 CodeSyncer 협업 시스템을 설정하세요.
>
> **프로젝트**: [PROJECT_NAME]
> **GitHub**: https://github.com/[GITHUB_USERNAME]/[PROJECT_NAME]
> **생성일**: [TODAY]
> **모노레포 도구**: [MONOREPO_TOOL]
> **워크스페이스 패턴**: [WORKSPACE_PATTERNS]

---

## 📋 당신의 임무

이 **모노레포** 워크스페이스를 분석하고 포괄적인 협업 시스템을 만드는 것이 임무입니다. 이것은 모노레포입니다 - 의존성과 도구를 공유하는 여러 패키지가 포함된 단일 레포지토리입니다.

다음 단계를 **대화형으로** 진행하세요 - 각 주요 결정 시점에서 사용자 확인을 받으세요.

---

## 🎯 1단계: 모노레포 구조 이해하기

### 감지된 패키지

[REPO_LIST]

### 모노레포 특수 고려사항

1. **공유 의존성**: 패키지들이 루트 레벨에서 공통 의존성을 공유할 수 있음
2. **내부 의존성**: 패키지들이 서로를 의존할 수 있음 (예: `@myorg/shared`)
3. **통합 빌드**: 모노레포는 통합된 빌드/테스트 스크립트를 가질 수 있음
4. **공통 설정**: 루트 레벨의 공유 설정 (tsconfig, eslint, prettier)

### 당신의 작업

1. **각 패키지 분석**:
   - 파일 구조와 로컬 의존성 검토
   - 기술 스택과 프레임워크 파악
   - 모노레포 내 패키지 목적과 역할 이해
   - 내부 의존성 (모노레포 내 다른 패키지 의존)
   - 다른 패키지가 사용하는 내보내기/API

2. **모노레포 아키텍처 이해**:
   - 루트 레벨 도구와 스크립트
   - 공유 설정
   - 빌드/배포 파이프라인
   - 패키지 간 의존 관계

---

## 🔄 2단계: 대화형 설정 프로세스

### 각 패키지마다:

#### 2.1 패키지 분석 확인
사용자에게 분석 결과 제시:
```
📦 패키지: [package-name]
📍 경로: [relative-path]

제 분석 결과:
- 타입: [backend/frontend/mobile/library/shared]
- 기술 스택: [detected stack]
- 설명: [생성한 설명]
- 내부 의존성: [이 모노레포에서 가져오는 패키지 목록]
- 내보내는 API: [다른 패키지가 가져갈 수 있는 것들]

이 분석이 맞나요? 수정할 부분이 있나요?
```

#### 2.2 중요 질문하기

**⚠️ 절대 추론하지 말고 반드시 물어보세요:**

1. **패키지 스코프** (@myorg/* 같은 스코프 패키지인 경우):
   - "이 모노레포의 npm 스코프가 무엇인가요?" (예: @myorg)
   - "패키지들이 npm에 배포되나요 아니면 내부용인가요?"

2. **패키지 간 의존성**:
   - "알아야 할 패키지 간 암묵적 의존성이 있나요?"
   - "어떤 패키지가 'leaf' 패키지이고 어떤 것이 'library' 패키지인가요?"

3. **공유 비즈니스 로직**:
   - "패키지 간에 공유되는 비즈니스 규칙이 있나요?"
   - "shared/common 패키지는 어디서 설정을 가져오나요?"

4. **API 계약**:
   - "프론트엔드와 백엔드 패키지가 어떻게 통신하나요?"
   - "패키지 간에 공유되는 타입/인터페이스가 있나요?"

5. **빌드 & 배포**:
   - "패키지들이 어떻게 빌드되고 배포되나요?"
   - "다른 패키지보다 먼저 빌드되어야 하는 패키지가 있나요?"

#### 2.3 패키지별 키워드 식별

각 패키지에 대해 도메인별 일시 정지 키워드를 물어보세요:
- **API 패키지**: 인증, 권한, 데이터베이스, 마이그레이션
- **UI 패키지**: 폼 검증, 사용자 입력, 접근성
- **공유 패키지**: 브레이킹 체인지, API 변경, 내보내기

---

## 📝 3단계: 문서 파일 생성

### 3.1 각 패키지별로

각 패키지의 `.claude/` 폴더에 다음 파일들을 생성:

#### CLAUDE.md
- 패키지별 코딩 규칙
- 내부 의존성 정보
- 패키지 내보내기 문서
- 패키지 간 통신 패턴

#### ARCHITECTURE.md
- 패키지 폴더 구조
- 패키지별 의존성 (외부 및 내부)
- 다른 패키지와의 통합 지점

#### COMMENT_GUIDE.md
- 표준 주석 가이드 (템플릿 사용)

#### DECISIONS.md
- 패키지 레벨 결정 로그

### 3.2 모노레포 특수 고려사항

문서 생성 시:

1. **내부 의존성 문서화**:
```typescript
// packages/web/.claude/CLAUDE.md 내용
## 내부 의존성
- `@myorg/shared` - 공통 유틸리티와 타입
- `@myorg/api-client` - 타입 안전 API 클라이언트

## Import 패턴
// ✅ 올바름: 패키지 이름으로 가져오기
import { Button } from '@myorg/ui';

// ❌ 틀림: 직접 경로 가져오기
import { Button } from '../../ui/src/Button';
```

2. **패키지 간 규칙**:
```typescript
// @codesyncer-rule: 공유 타입 변경 시 모든 의존 패키지 업데이트 필요
// @codesyncer-context: 이 타입은 packages/web과 packages/mobile에서 사용됨
export interface User {
  id: string;
  name: string;
}
```

3. **빌드 순서 문서화**:
```
빌드 의존성:
1. packages/shared (의존성 없음)
2. packages/ui (shared 의존)
3. packages/api-client (shared 의존)
4. packages/web (ui, api-client 의존)
```

---

## 🌐 4단계: 루트 문서 생성

### 4.1 CLAUDE.md (루트)

모노레포 루트에 `CLAUDE.md` 생성:
- 모노레포 개요와 구조
- 패키지 의존성 그래프
- 모든 패키지 공통 규칙
- 빌드 및 개발 명령어
- 패키지 간 워크플로우 예시

### 4.2 .codesyncer/MASTER_CODESYNCER.md

마스터 문서 생성:
- 경로와 역할이 포함된 전체 패키지 맵
- 패키지 간 네비게이션 규칙
- 키워드-패키지 매핑
- 모노레포 특수 워크플로우

예시 내용:
```markdown
## 📦 패키지 맵

| 패키지 | 경로 | 역할 | 내부 의존성 |
|--------|------|------|-------------|
| @myorg/shared | packages/shared | 공통 유틸리티 | - |
| @myorg/ui | packages/ui | 컴포넌트 라이브러리 | shared |
| @myorg/web | apps/web | 웹 애플리케이션 | shared, ui |
| @myorg/api | apps/api | 백엔드 API | shared |

## 🔄 자동 전환 규칙

다음 키워드 언급 시:
- "컴포넌트", "버튼", "UI" → packages/ui에서 작업
- "API", "엔드포인트", "서버" → apps/api에서 작업
- "페이지", "라우트", "웹" → apps/web에서 작업
- "공유", "공통", "유틸" → packages/shared에서 작업
```

---

## ✅ 5단계: 최종 확인

모든 파일 생성 후 요약 제시:

```
✅ CodeSyncer 모노레포 설정 완료!

생성된 파일:
📁 루트/
   ├── CLAUDE.md ⭐ 클로드가 먼저 읽는 파일
   └── .codesyncer/
       └── MASTER_CODESYNCER.md

📁 packages/shared/.claude/
   ├── CLAUDE.md
   ├── ARCHITECTURE.md
   ├── COMMENT_GUIDE.md
   └── DECISIONS.md

📁 packages/ui/.claude/
   └── (동일한 파일들)

📁 apps/web/.claude/
   └── (동일한 파일들)

📁 apps/api/.claude/
   └── (동일한 파일들)

문서화된 모노레포 기능:
✓ 패키지 의존성 그래프
✓ 내부 import 패턴
✓ 패키지 간 워크플로우
✓ 빌드 순서 의존성
✓ 공유 설정 노트

다음 단계:
1. 생성된 파일 검토
2. 패키지별 규칙 커스터마이즈
3. 주요 변경 후 "codesyncer update" 실행

CodeSyncer 사용 준비 완료!
```

---

## 🎨 패키지 타입별 가이드라인

### 라이브러리/공유 패키지:
- 모든 내보내기 철저히 문서화
- 브레이킹 체인지 영향 명시
- 사용하는 모든 패키지 목록화
- 버저닝 가이드라인 포함

### 애플리케이션 패키지 (apps/):
- 진입점 문서화
- 배포 대상 명시
- 환경 설정 포함
- 외부 연동 문서화

### UI/컴포넌트 패키지:
- 컴포넌트 사용 예시 포함
- props와 타입 문서화
- 스타일링 접근법 명시
- 접근성 요구사항 포함

---

## 🚨 AI 어시스턴트를 위한 모노레포 특수 규칙

1. **패키지 경계 이해**:
   - 현재 작업 중인 패키지 파악
   - import/export 관계 이해
   - 순환 의존성 절대 금지

2. **패키지 간 변경**:
   - 공유 패키지 변경 시 모든 소비자 고려
   - shared에서 타입 업데이트 후 소비자 업데이트
   - 영향받는 패키지 전체 테스트 실행

3. **내부 의존성**:
   - 항상 패키지 이름으로 가져오기 (상대 경로 아님)
   - 변경이 의존 패키지에 영향을 주는지 확인
   - 브레이킹 체인지는 DECISIONS.md에 문서화

4. **빌드 고려사항**:
   - 빌드 순서 파악
   - 변경이 의존성 재빌드를 필요로 하는지 이해
   - 빌드 타임 설정 문서화

---

## 📚 템플릿 플레이스홀더

파일 생성 시 다음을 교체:

- `[PROJECT_NAME]` → 사용자 프로젝트명
- `[GITHUB_USERNAME]` → 사용자 GitHub 사용자명
- `[TODAY]` → 현재 날짜 (YYYY-MM-DD)
- `[MONOREPO_TOOL]` → 감지된 모노레포 도구
- `[WORKSPACE_PATTERNS]` → 워크스페이스 glob 패턴
- `[PACKAGE_NAME]` → 개별 패키지 이름
- `[PACKAGE_PATH]` → 패키지 상대 경로
- `[INTERNAL_DEPS]` → 내부 의존성 목록

---

## 🎯 성공 기준

다음 조건이 충족되면 설정 성공:
- ✅ 모든 패키지에 완전한 .claude/ 폴더 생성
- ✅ 루트 CLAUDE.md에 모노레포 구조 문서화
- ✅ 마스터 문서에 패키지 의존성 맵 포함
- ✅ 패키지 간 관계 문서화
- ✅ 빌드 순서 문서화
- ✅ 비즈니스 로직에 대한 추론 없음
- ✅ 모든 문서가 @codesyncer-* 태그 형식 사용

---

**버전**: 1.0.0 (Powered by CodeSyncer)
**AI 도구**: Claude Code 최적화 | 호환: Cursor, GitHub Copilot, Continue.dev

---

*이 설정 가이드는 CodeSyncer CLI에 의해 생성됩니다. 문제나 개선사항은 https://github.com/bitjaru/codesyncer 방문*

<!-- codesyncer-version: 3.1.1 -->
